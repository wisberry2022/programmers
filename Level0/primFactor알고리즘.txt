4 8 =(%1)= 0 0    [1]
4 8 =(%2)= 0 0    [1,2]
4 8 =(%3)= 1 2    [1,2]
4 8 =(%4)= 0 0    [1,2,4]

11 22 =(%1)= 0 0 [1]
11 22 =(%2)= 1 0 [1]
11 22 =(%3)= 2 1 [1]
...
11 22 =(%11)= 0 0 [1,11]

소인수 구하기 알고리즘

8의 인수 [1,2,4,8]

2 =(%1)= 0 [1]
  =(%2)= 0 [1,2]

4 =(%1)= 0 [1]
  =(%2)= 0 [1,2]
  =(%3)= 1 [1,2]
  =(%4)= 0 [1,2,4]


[2,5] = O
[2] = O
[5] = O
[2,3] = X

1) 두 수의 최대공약수가 있을 경우 - 기약분수 아님
	* 분모가 분자보다 작을 때 - 2/30 3/15 
	* 분모가 분자보다 클 때 - 30/2 15/3

2) 두 수의 최대공약수가 없을 경우 -- 기약 분수임
	* 분모가 분자보다 작을 때 - 1/25 3/9 
	* 분모가 분자보다 클 때 - 25/1 3/9


0. 두 수를 입력받는다
	0-a. 두 수가 같을 경우 (정수이므로 무조건 1 return)
	0-b. 두 수가 다를 경우(유리수 형태)
		1. 두 수의 최대공약수를 구한다.
			1-1-a. 두 수의 최대공약수가 있을 경우
				1-1-a-1. 기약분수가 아니므로, 두 수를 최대공약수로 나누어 기약분수로 만든다.
				1-1-a-2. 분모의 인수를 구한다.
				1-1-a-3. 분모의 인수 중 2와 5가 포함되어있는지 확인한다.
					1-1-a-3-A. 2나 5가 포함되어있을 경우, 1 return
					1-1-a-3-B. 2나 5가 포함되어있지않을 경우, 2 return  
			1-1-b. 두 수의 최대공약수가 없을 경우	
				1-1-b-1. 분모의 인수를 구한다.
				1-1-b-2. 분모의 인수 중 2와 5가 포함되어있는지 확인한다.
					1-1-b-2-A. 2와 5가 포함되어있을 경우, 1 return
					1-1-b-2-B. 2나 5가 포함되어있지 않을 경우, 2 return